// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import { Big } from "big.js";
import { Alert, Platform } from "react-native";
import { check, request, RESULTS, openSettings, PERMISSIONS } from "react-native-permissions";

// BEGIN EXTRA CODE
type PermissionName = "CAMERA";
const permissionNameMapping = Object.freeze({
    APP_TRACKING_TRANSPARENCY: Platform.select({
        ios: PERMISSIONS.IOS.APP_TRACKING_TRANSPARENCY
    }),
    BLUETOOTH_PERIPHERAL: Platform.select({
        ios: PERMISSIONS.IOS.BLUETOOTH_PERIPHERAL,
        android: PERMISSIONS.ANDROID.BLUETOOTH_CONNECT
    }),
    CALENDAR: Platform.select({
        ios: PERMISSIONS.IOS.CALENDARS,
        android: PERMISSIONS.ANDROID.READ_CALENDAR
    }),
    CAMERA: Platform.select({
        ios: PERMISSIONS.IOS.CAMERA,
        android: PERMISSIONS.ANDROID.CAMERA
    }),
    CONTACTS: Platform.select({
        ios: PERMISSIONS.IOS.CONTACTS,
        android: PERMISSIONS.ANDROID.READ_CONTACTS // check write contact permission
    }),
    WRITE_CONTACTS: Platform.select({
        ios: PERMISSIONS.IOS.CONTACTS,
        android: PERMISSIONS.ANDROID.WRITE_CONTACTS // check write contact permission
    }),
    FACE_ID: Platform.select({
        ios: PERMISSIONS.IOS.FACE_ID
    }),
    LOCATION_ALWAYS: Platform.select({
        ios: PERMISSIONS.IOS.LOCATION_ALWAYS,
        android: PERMISSIONS.ANDROID.ACCESS_BACKGROUND_LOCATION
    }),
    LOCATION: Platform.select({
        ios: PERMISSIONS.IOS.LOCATION_WHEN_IN_USE,
        android: PERMISSIONS.ANDROID.ACCESS_FINE_LOCATION
    })
});
/**
 * 
 APP_TRACKING_TRANSPARENCY;
BLUETOOTH_PERIPHERAL;
CALENDARS;
CAMERA;
CONTACTS;
FACE_ID;
LOCATION_ALWAYS;
LOCATION_WHEN_IN_USE;
MEDIA_LIBRARY;
MICROPHONE;
MOTION;
PHOTO_LIBRARY;
PHOTO_LIBRARY_ADD_ONLY;
REMINDERS;
SIRI;
SPEECH_RECOGNITION;
STOREKIT;
 */
function handleBlockedPermission(): void {
    Alert.alert("title", "need to go to settings for activation", [
        // draft text
        { text: "go to settings", onPress: () => openSettings() },
        { text: "cancel" }
    ]);
}
// END EXTRA CODE

/**
 * @param {"NanoflowCommons.Enum_Permissions.CAMERA"|"NanoflowCommons.Enum_Permissions.CONTACTS"} permission - This field is required.
 * @returns {Promise.<"NanoflowCommons.Enum_PermissionStatus.unavailable"|"NanoflowCommons.Enum_PermissionStatus.denied"|"NanoflowCommons.Enum_PermissionStatus.limited"|"NanoflowCommons.Enum_PermissionStatus.granted"|"NanoflowCommons.Enum_PermissionStatus.blocked">}
 */
export async function GenericPermission(
    permission: PermissionName
): Promise<"unavailable" | "blocked" | "denied" | "granted" | "limited"> {
    // BEGIN USER CODE
    if (!permission) {
        return Promise.reject(new Error("Input parameter 'permission' is required"));
    }
    const mappedPermissionName = permissionNameMapping[permission];
    const permissionStatus = await check(mappedPermissionName!);

    switch (permissionStatus) {
        case RESULTS.GRANTED:
        case RESULTS.UNAVAILABLE:
        case RESULTS.LIMITED:
            return permissionStatus;
        case RESULTS.BLOCKED:
            handleBlockedPermission(); // check with chris
            return RESULTS.BLOCKED;
        case RESULTS.DENIED:
            return request(mappedPermissionName!);
    }
    // END USER CODE
}
